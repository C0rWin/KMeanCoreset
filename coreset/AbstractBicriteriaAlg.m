classdef AbstractBicriteriaAlg < HandleObject
%--------------------------------------------------------------------------
%This is the major class computing the bicriteria clustering of a given set
%of points (with weights). Given the set of points represented as
%originalF, with the weight information included, the class calls the compute() 
%function to compute the bicriteria clustering of originalF. The resulted 
%clusters are stored in the member variable clusterVec.
%
%The basic idea of the algorithm goes as follows. In every iteration, we
%compute \beta ROBUST centers of the currently unclustered set of points
%(this \beta centers are generated by random sampling with probability
%proportional to their weights). Then we select roughly the first half of
%the points (in fact we refer to weights here. A point with weight 5 can be
%roughly thought of as 5 points in the same position), according to the
%sorting of the distances of the points to their respective nearest ROBUST
%center from smallest to the greatest, to be clustered to the \beta ROBUST
%centers we've found in this iteration. We repeat the process until finally
%every point belongs to one cluster of a ROBUST center. Finally we shall
%have at most \beta times \log(n) clusters, each has one center.

%In the Bicriteria algorithm, we provide the following parameters that
%testers can tune with (any variable with comment "Testable" is the one
%that can be changed outside):
%   1. minFunctionSize: it determines when to stop the while-loop in the
%       compute function. In other words, it determines how many points are
%       left for the final round of clustering. By default it is 10.
%
%
%   3. robustNIteration: it determines the number of iterations needed to
%       select a subset of robust centers in the robust median algorithm.
%       By default it is 1.
%
%   4. partitionFraction: it determines the number of points put into new
%       clusters in every iteration. By default it is half (0.5).
%
%   5. beta: it determines the number of robust centers returned in each
%       iteration. It must be set from outside.
%
%   6. robustAlg: robust median algorithm. 
%
%   7. ptasAlg: robust median without outliers. By default it is
%       implemented in AbstractPtasAlg.m.
%
%   8. orderStatisticsAlg: sorting algorithm. By default it is implemented
%       in OrderStatisticBySortAlg.m.
%--------------------------------------------------------------------------

    properties 
       % number of min functions before end of recursion
       % Testable
       minFunctionSize = 10;
            
	   % Set by default. But the coreset algorithm can also assign its preferred Robust Median algorithms
	   % For ptasAlg and orderStatisticsAlg, we deal with them in the same way
       % Testable
       robustAlg = RandomRobustAlg();
       
       % Testable
       % by default: RandomRobustAlg.robustAlg
       ptasAlg = [];

       % show iteration number 
       figure;
       % Testable
       orderStatisticsAlg = OrderStatisticBySortAlg();
       
       % update nearest center after all calls for better approximation
       update;
       
       % Whether to use the GPU code processing path. Applicable also if useGPU is set to false
       % to use CPU processing, but have the same path for proper comparison
       useGPUPath = false;
       % Whether to use the GPU for processing, only active if also useGPUPath is set to true
       useGPU = false;
       % Enable optional timing information
       timecode = false;
    end % properties
    
    properties (SetAccess = private)
       
       % current iteration number
       nIteration;
       
       % Type = ClusterVector
       clusterVec = ClusterVector();
    end
    
    methods
       
       % Compute the bicriteria clusters. It is the major function used by
       % the coreset algorithm to obtain clusters.
       % The function returns a ClusterVector object
       function clusters = compute(obj, originalF)
            if obj.useGPUPath
                 clusters = computeGPU(obj, originalF);
            else
                 clusters = computeOrig(obj, originalF);
            end
       end % compute

       function clusters = computeOrig(obj, originalF)
            if isempty(obj.ptasAlg)
                obj.ptasAlg = obj.robustAlg.onSampleAlg;
            end % if
            F=originalF;
            
            % Main idea: We keep the original F unchanged, but only change
            % the vector of indexes. We use "currentIndexes" as a
            % mapping/filter to filter specific lines of information from
            % original F.
            % Initialization of currentIndexes;
            currentIndexes = 1:F.size;
            obj.clusterVec=ClusterVector;
%            obj.clusterVec.init(ceil(obj.beta), true);

            obj.nIteration=0;
            
            % Recall that here we consider the most general weighted case.
            % So the total length of the currentIndexes should be the sum
            % of the total weight.
            lci = F.sumW;
          
            while lci >= obj.minFunctionSize % Loop terminating condition according to the paper. 
                %lci here is roughly the number of un-clustered points.
                obj.nIteration = obj.nIteration + 1;
                if obj.figure
                    disp(['bicriteria iteration ' num2str(obj.nIteration)]);
                end
                % Beta centers that represents the robust median of F with
                % their respective clusters.
                % Obtain a (medianFraction, epsilon, beta)-robust median
                % according to the paper. Different subclass can have
                % different approaches for this.
                smallerClusters = ...
                     obj.robustAlg.compute(F.subset(currentIndexes));

                % Append the selected smallerClusters to obj.clusterVec
                % "currentIndexes" information is necessary to maintain the
                % point indexes.
                obj.clusterVec.union(smallerClusters, currentIndexes);
                
   			    % Corresponds to F_{i+1} = F_i \ G_i in the paper.
                % We only shrink the indexes set: currentIndexes
                currentIndexes(smallerClusters.pointIndexes) = [];
                lci = sum(F.W.matrix(currentIndexes));
            end % while
			
            if not(isempty(currentIndexes))
                % This is for the last cluster
                % This corresponds to Line 7 of Fig. 1 in the paper.
                try
                  robustClusters = obj.ptasAlg.computeClusterVec(F.subset(currentIndexes));
                catch error
                  disp(error)
                  return
                  
                end
                i=obj.nIteration;
                if obj.figure
                    Utils.show('clear',true);
                    robustClusters.show();
                    Utils.show('pause', true, 'title', ['Remaining points in last iteration and their approximation. Number of bicriteria iterations: ' num2str(i)]);
                end
                % Append the final cluster vectors directly to
                % obj.clusterVec.
                obj.clusterVec.union(robustClusters, currentIndexes);
            end
            if obj.figure
                Utils.show('clear',true);
                obj.clusterVec.show();
                Utils.show('pause', true, 'title', 'Input points with its bicriteria');
            end
            
            if obj.clusterVec.nPoints~= originalF.M.n || obj.clusterVec.isInfDist()
                error('bad bicriteria');
            end
            if obj.update
                    obj.clusterVec.updateNearestCenters();
            end %if
            clusters = obj.clusterVec;
       end % computeOrig

       function clusters = computeGPU(obj, originalF)

            if (obj.timecode) ; tt = tic ; ttt = toc(tt) ; i = 2 ; end

            T = GPUPathAbstract(obj.useGPU);
            T.nIterations =  obj.robustAlg.nIterations;
            T.beta = single(obj.robustAlg.beta);
            T.partitionFraction = single(obj.robustAlg.partitionFraction);

            if isempty(obj.ptasAlg)
                obj.ptasAlg = obj.robustAlg.onSampleAlg;
            end % if

            if (obj.timecode) ; ttt(i) = toc(tt) ; i = i + 1 ; end

            % This is used in any case to keep things simple for now
            % It's affects on speed need to be determined
     
            if (obj.useGPU)
                FM = gpuArray(single(originalF.M.m));
            else
                FM = single(originalF.M.m);
            end

            if (obj.timecode) ; ttt(i) = toc(tt) ; i = i + 1 ; end

            FW = single(originalF.W.m);

            if (obj.timecode) ; ttt(i) = toc(tt) ; i = i + 1 ; end

            % Main idea: We keep the original F unchanged, but only change
            % the vector of indexes. We use "currentIndexes" as a
            % mapping/filter to filter specific lines of information from
            % original F.
            % Initialization of currentIndexes;
            currentIndexes = (1:size(FM, 1))';
            obj.clusterVec = ClusterVector;

            % TODO: GM and GW could also probably use pre-allocation, but
            % their end size is not clear
            optCluster.GM = [];
            optCluster.GW = [];
            optCluster.pointIndexes = zeros(size(FM, 1), 1);
            optCluster.distances = zeros(size(FM, 1), 1, 'single');
            optCluster.centerIndexes = zeros(size(FM, 1), 1);
            
            pos = 1;

%            obj.clusterVec.init(ceil(obj.beta), true);

            obj.nIteration=0;

            % Recall that here we consider the most general weighted case.
            % So the total length of the currentIndexes should be the sum
            % of the total weight.
            lci = sum(FW);

            if (obj.timecode) ; ttt(i) = toc(tt) ; fprintf('Setup ') ; disp(ttt(2:end) - ttt(1:end-1)) ; end

            while lci >= obj.minFunctionSize % Loop terminating condition according to the paper. 
                if (obj.timecode) ; tt = tic ; ttt = toc(tt) ; i = 2 ; n = length(FW) ; end

                %lci here is roughly the number of un-clustered points.
                obj.nIteration = obj.nIteration + 1;
                if obj.figure
                    disp(['bicriteria iteration ' num2str(obj.nIteration)]);
                end
                % Beta centers that represents the robust median of F with
                % their respective clusters.
                % Obtain a (medianFraction, epsilon, beta)-robust median
                % according to the paper. Different subclass can have
                % different approaches for this.
                if (T.gpu)
                    smallerClusters = T.compute(FM, gpuArray(FW), FW);
                else
                    smallerClusters = T.compute(FM, FW, FW);
                end

                if (obj.timecode) ; ttt(i) = toc(tt) ; i = i + 1 ; end

                % Append the selected smallerClusters to obj.clusterVec
                % "currentIndexes" information is necessary to maintain the
                % point indexes.

                lg = size(optCluster.GM, 1);
                optCluster.GM = [optCluster.GM ; smallerClusters.GM];
                optCluster.GW = [optCluster.GW ; smallerClusters.GW];
                optCluster.pointIndexes(pos:pos+length(smallerClusters.pointIndexes)-1) = currentIndexes(smallerClusters.pointIndexes);
                optCluster.distances(pos:pos+length(smallerClusters.pointIndexes)-1) = smallerClusters.distances;
                optCluster.centerIndexes(pos:pos+length(smallerClusters.pointIndexes)-1) = smallerClusters.centerIndexes + lg;
                
                pos = pos + length(smallerClusters.pointIndexes);
                
   			    % Corresponds to F_{i+1} = F_i \ G_i in the paper.
                % We only shrink the indexes set: currentIndexes
                currentIndexes(smallerClusters.pointIndexes) = [];
                % TODO: GPU is more efficient at copying than deleting
                FM(smallerClusters.pointIndexes, :) = [];
                FW(smallerClusters.pointIndexes) = [];

                if (obj.timecode) ; ttt(i) = toc(tt) ; i = i + 1 ; end

                lci = sum(FW);

                if (obj.useGPU && size(FM, 1) < 100000 && isa(FM, 'parallel.gpu.GPUArray'))
                    FM = gather(FM);
                    FW = gather(FW);
                    T.gpu = false;
                end

                if (obj.timecode) ; ttt(i) = toc(tt) ; fprintf('%g,%g,%g,',obj.nIteration, n, ttt(end)) ; fprintf('%g,', ttt(2:end) - ttt(1:end-1)) ; fprintf('\n') ; end
            end % while

            if (obj.timecode) ; tt = tic ; end

            if not(isempty(currentIndexes))
                % This is for the last cluster
                % This corresponds to Line 7 of Fig. 1 in the paper.
                robustClusters = obj.ptasAlg.computeClusterVec(originalF.subset(currentIndexes));
                i=obj.nIteration;
                if obj.figure
                    Utils.show('clear',true);
                    robustClusters.show();
                    Utils.show('pause', true, 'title', ['Remaining points in last iteration and their approximation. Number of bicriteria iterations: ' num2str(i)]);
                end
            end

            lg = size(optCluster.GM, 1);
            optCluster.GM = [optCluster.GM ; robustClusters.centers.M.m];
            optCluster.GW = [optCluster.GW ; robustClusters.centers.W.m];
            optCluster.pointIndexes(pos:pos+length(robustClusters.pointIndexes)-1) = currentIndexes(robustClusters.pointIndexes);
            optCluster.distances(pos:pos+length(robustClusters.pointIndexes)-1) = robustClusters.distances;
            optCluster.centerIndexes(pos:pos+length(robustClusters.pointIndexes)-1) = robustClusters.centerIndexes + lg;
            
            pos = pos + length(robustClusters.pointIndexes);

            G = PointFunctionSet(Matrix(double(optCluster.GM)), Matrix(double(optCluster.GW)));
            obj.clusterVec.initWithFunctionSet(originalF, optCluster.pointIndexes, optCluster.distances, G, optCluster.centerIndexes)

            if obj.figure
                Utils.show('clear',true);
                obj.clusterVec.show();
                Utils.show('pause', true, 'title', 'Input points with its bicriteria');
            end
            
            if pos - 1 ~= originalF.M.n || obj.clusterVec.isInfDist()
                error('bad bicriteria');
            end
            if obj.update
                    obj.clusterVec.updateNearestCenters();
            end %if
            clusters = obj.clusterVec;

            if (obj.timecode) ; ttt = toc(tt); fprintf('finish %g\n', ttt) ; end
       end; % computeGPU
       end % methods
        
end % class 
